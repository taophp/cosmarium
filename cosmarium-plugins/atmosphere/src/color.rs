use serde::{Serialize, Deserialize};

/// Represents a color palette generated by the Atmosphere plugin
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AtmospherePalette {
    pub main_bg: String,      // CSS hsl()
    pub main_bg_h: f32,
    pub main_bg_s: f32,
    pub main_bg_l: f32,
    
    pub main_fg: String,      // CSS hsl()
    pub main_fg_h: f32,
    pub main_fg_s: f32,
    pub main_fg_l: f32,
    
    pub accent_1: String,
    pub accent_1_h: f32,
    pub accent_1_s: f32,
    pub accent_1_l: f32,
    
    pub accent_2: String,
    pub accent_3: String,
    pub is_light: bool,
    pub color_name: String,
}

/// Harmony types based on RYB wheel geometry
#[derive(Debug, Clone, Copy)]
pub enum Harmony {
    Mono,
    Complementary,
    Adjacent,
    Triad,
    Tetrad,
}

/// Core RYB color wheel logic
pub struct RybWheel;

impl RybWheel {
    /// Smooth monotone spline interpolation (Hermite variant)
    /// Ported from user's JS implementation
    fn spline_interp(x: f32, xs: &[f32], ys: &[f32]) -> f32 {
        let n = xs.len();
        if x <= xs[0] { return ys[0]; }
        if x >= xs[n - 1] { return ys[n - 1]; }
        
        let mut i = 1;
        while x > xs[i] { i += 1; }
        
        let x0 = xs[i - 1];
        let x1 = xs[i];
        let y0 = ys[i - 1];
        let y1 = ys[i];
        
        let t = (x - x0) / (x1 - x0);
        
        let d0 = if i > 1 {
            (ys[i] - ys[i - 2]) / (xs[i] - xs[i - 2])
        } else {
            (y1 - y0) / (x1 - x0)
        };
        
        let d1 = if i < n - 1 {
            (ys[i + 1] - ys[i - 1]) / (xs[i + 1] - xs[i - 1])
        } else {
            (y1 - y0) / (x1 - x0)
        };
        
        let t2 = t * t;
        let t3 = t2 * t;
        
        let h00 = 2.0 * t3 - 3.0 * t2 + 1.0;
        let h10 = t3 - 2.0 * t2 + t;
        let h01 = -2.0 * t3 + 3.0 * t2;
        let h11 = t3 - t2;
        
        h00 * y0 + h10 * d0 * (x1 - x0) + h01 * y1 + h11 * d1 * (x1 - x0)
    }

    /// Main RYB rotation using continuous spline mapping
    /// Input hue 'h' is standard HSL (0-360)
    /// 'amount' is rotation in RYB space (0-360)
    /// Returns new HSL hue (0-360)
    pub fn spin(h: f32, amount: f32) -> f32 {
        let wheel = [
            (0.0, 0.0), (22.0, 30.0), (33.0, 60.0), (47.0, 90.0),
            (60.0, 120.0), (78.0, 150.0), (120.0, 180.0),
            (192.0, 210.0), (240.0, 240.0), (360.0, 360.0)
        ];

        let xs: Vec<f32> = wheel.iter().map(|(hsl, _)| *hsl).collect();
        let ys: Vec<f32> = wheel.iter().map(|(_, ryb)| *ryb).collect();

        // Normalize input
        let h = ((h % 360.0) + 360.0) % 360.0;

        // Forward transform (HSL -> RYB)
        let ryb = Self::spline_interp(h, &xs, &ys);

        // Apply rotation in RYB space
        let new_ryb = (ryb + amount + 360.0) % 360.0;

        // Inverse transform (RYB -> HSL)
        // Note: we swap xs and ys for inverse lookup
        Self::spline_interp(new_ryb, &ys, &xs)
    }

    /// Get a human-readable name for a RYB hue
    pub fn get_color_name(ryb_hue: f32) -> String {
        let h = ((ryb_hue % 360.0) + 360.0) % 360.0;
        if h < 15.0 || h >= 345.0 { "Passion Red".to_string() }
        else if h < 45.0 { "Warm Orange".to_string() }
        else if h < 75.0 { "Sunny Yellow".to_string() }
        else if h < 165.0 { "Hopeful Green".to_string() }
        else if h < 195.0 { "Turquoise".to_string() }
        else if h < 255.0 { "Deep Blue".to_string() }
        else if h < 315.0 { "Vivid Violet".to_string() }
        else { "Rose".to_string() }
    }

    /// Generate a full palette based on a base RYB hue and harmony
    /// 'intensity' (0.0 - 1.0) modulates saturation and lightness contrast
    pub fn generate_palette(h_ryb: f32, base_s: f32, base_l: f32, harmony: Harmony, intensity: f32) -> AtmospherePalette {
        let intensity = intensity.clamp(0.05, 1.0); // Minimum intensity for visibility
        
        // Convert base RYB hue to HSL hue for technical representation
        let h_hsl = Self::spin(0.0, h_ryb); 
        
        // Define rotations for different scheme components
        let scheme = match harmony {
            Harmony::Mono => vec![0.0, 0.0, 0.0],
            Harmony::Complementary => vec![0.0, 180.0, 180.0],
            Harmony::Adjacent => vec![0.0, 30.0, -30.0],
            Harmony::Triad => vec![0.0, 120.0, 240.0],
            Harmony::Tetrad => vec![0.0, 90.0, 180.0], // Simplified tetrad
        };

        let hues: Vec<f32> = scheme.iter().map(|&rot| Self::spin(h_hsl, rot)).collect();
        
        // Decide Dark/Light mode based on base lightness
        let is_light = base_l > 50.0;

        // Modulate saturation and lightness based on intensity
        // Lower intensity = closer to neutral gray/dark
        let s = base_s * intensity;
        
        // Lightness pulls towards target_l from neutral (0.05 or 0.95)
        let neutral_l = if is_light { 0.95 } else { 0.05 };
        let l = neutral_l + (base_l / 100.0 - neutral_l) * intensity;
        let l = l * 100.0;

        // Background is always the base color (or slightly modulated)
        let b_h = hues[0];
        let b_s = s;
        let b_l = l;
        let main_bg = format!("hsl({:.1}, {:.1}%, {:.1}%)", b_h, b_s, b_l);
        
        // Foreground should contrast with background
        let f_h = hues[0];
        let f_s = s * 0.3;
        let f_l = if is_light {
            (l - 70.0).max(10.0)
        } else {
            (l + 70.0).min(95.0)
        };
        let main_fg = format!("hsl({:.1}, {:.1}%, {:.1}%)", f_h, f_s, f_l);

        // Accent 1
        let a1_h = hues[1 % hues.len()];
        let a1_s = s;
        let a1_l = l;
        let accent_1 = format!("hsl({:.1}, {:.1}%, {:.1}%)", a1_h, a1_s, a1_l);

        AtmospherePalette {
            main_bg,
            main_bg_h: b_h,
            main_bg_s: b_s,
            main_bg_l: b_l,
            
            main_fg,
            main_fg_h: f_h,
            main_fg_s: f_s,
            main_fg_l: f_l,
            
            accent_1,
            accent_1_h: a1_h,
            accent_1_s: a1_s,
            accent_1_l: a1_l,
            
            accent_2: format!("hsl({:.1}, {:.1}%, {:.1}%)", hues[2 % hues.len()], s, l),
            accent_3: format!("hsl({:.1}, {:.1}%, {:.1}%)", hues[0], s, l), // fallback
            is_light,
            color_name: Self::get_color_name(h_ryb),
        }
    }
}
